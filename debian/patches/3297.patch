Last-Update: 2014-12-13
Forwarded: not-needed
Origin: upstream, http://www.midnight-commander.org/changeset/a3486faac37680e3bcf7d0b3905f745765a823fd
Bug-MC: https://www.midnight-commander.org/ticket/3297
Bug-Debian: http://bugs.debian.org/767463
From: Andrew Borodin <aborodin@vmail.ru>
Description: don't lose file in case of preallocate space fail.

 Don't remove the destination file if it was retrieved incompletely
 but it was already exist and appended during copy/move operation.

--- a/src/filemanager/file.c
+++ b/src/filemanager/file.c
@@ -1507,9 +1507,8 @@
     dest_status_t dst_status = DEST_NONE;
     int open_flags;
     gboolean is_first_time = TRUE;
     vfs_path_t *src_vpath = NULL, *dst_vpath = NULL;
-    gboolean write_errno_nospace = FALSE;
 
     /* FIXME: We should not be using global variables! */
     ctx->do_reget = 0;
     return_status = FILE_RETRY;
@@ -1749,30 +1748,41 @@
         }
         goto ret;
     }
 
-    while (TRUE)
+    /* try preallocate space; if fail, try copy anyway */
+    while (vfs_preallocate (dest_desc, file_size, ctx->do_append != 0 ? sb.st_size : 0) != 0)
     {
-        errno = vfs_preallocate (dest_desc, file_size, (ctx->do_append != 0) ? sb.st_size : 0);
-        if (errno == 0)
+        if (ctx->skip_all)
+        {
+            /* cannot allocate, start the file copying anyway */
+            return_status = FILE_CONT;
             break;
+        }
 
-        if (ctx->skip_all)
-            return_status = FILE_SKIPALL;
-        else
+        return_status =
+            file_error (_("Cannot preallocate space for target file \"%s\"\n%s"), dst_path);
+
+        if (return_status == FILE_SKIPALL)
+            ctx->skip_all = TRUE;
+
+        if (ctx->skip_all || return_status == FILE_SKIP)
         {
-            return_status =
-                file_error (_("Cannot preallocate space for target file \"%s\"\n%s"), dst_path);
-            if (return_status == FILE_RETRY)
-                continue;
-            if (return_status == FILE_SKIPALL)
-                ctx->skip_all = TRUE;
+            /* skip the space allocation error, start file copying */
+            return_status = FILE_CONT;
+            break;
         }
-        mc_close (dest_desc);
-        dest_desc = -1;
-        mc_unlink (dst_vpath);
-        dst_status = DEST_NONE;
-        goto ret;
+
+        if (return_status == FILE_ABORT)
+        {
+            mc_close (dest_desc);
+            dest_desc = -1;
+            mc_unlink (dst_vpath);
+            dst_status = DEST_NONE;
+            goto ret;
+        }
+
+        /* return_status == FILE_RETRY -- try allocate space again */
     }
 
     ctx->eta_secs = 0.0;
     ctx->bps = 0;
@@ -1832,8 +1842,10 @@
 
                 /* dst_write */
                 while ((n_written = mc_write (dest_desc, t, n_read)) < n_read)
                 {
+                    gboolean write_errno_nospace;
+
                     if (n_written > 0)
                     {
                         n_read -= n_written;
                         t += n_written;
@@ -1861,12 +1873,8 @@
                             goto ret;
                     }
                     if (return_status != FILE_RETRY)
                         goto ret;
-
-                    /* User pressed "Retry". Will the next mc_write() call be successful?
-                     * Reset error flag to be ready for that. */
-                    write_errno_nospace = FALSE;
                 }
             }
 
             tctx->copied_bytes = tctx->progress_bytes + n_read_total + ctx->do_reget;
@@ -1943,18 +1951,11 @@
     }
 
     if (dst_status == DEST_SHORT)
     {
-        /* Remove short file */
-        int result = 0;
-
-        /* In case of copy/move to full partition, keep source file
-         * and remove incomplete destination one */
-        if (!write_errno_nospace)
-            result = query_dialog (Q_ ("DialogTitle|Copy"),
-                                   _("Incomplete file was retrieved. Keep it?"),
-                                   D_ERROR, 2, _("&Delete"), _("&Keep"));
-        if (result == 0)
+        /* Query to remove short file */
+        if (query_dialog (Q_ ("DialogTitle|Copy"), _("Incomplete file was retrieved. Keep it?"),
+                          D_ERROR, 2, _("&Delete"), _("&Keep")) == 0)
             mc_unlink (dst_vpath);
     }
     else if (dst_status == DEST_FULL)
     {
