Last-Update: 2014-12-13
Forwarded: not-needed
Origin: upstream, http://www.midnight-commander.org/changeset/fe8a0a410f058bcb1080efe77304210350ff2339
Author: Andrew Borodin <aborodin@vmail.ru>
Bug-MC: https://www.midnight-commander.org/ticket/2966
Bug-Debian: http://bugs.debian.org/700569
Description: use mc_pipe_t to show command output, fixes view of broken manpages.

--- a/lib/util.h
+++ b/lib/util.h
@@ -26,8 +26,15 @@
 
 #define mc_return_if_error(mcerror) do { if (mcerror != NULL && *mcerror != NULL) return; } while (0)
 #define mc_return_val_if_error(mcerror, mcvalue) do { if (mcerror != NULL && *mcerror != NULL) return mcvalue; } while (0)
 
+#define MC_PIPE_BUFSIZE BUF_8K
+#define MC_PIPE_STREAM_EOF 0
+#define MC_PIPE_STREAM_UNREAD -1
+#define MC_PIPE_ERROR_CREATE_PIPE -2
+#define MC_PIPE_ERROR_PARSE_COMMAND -3
+#define MC_PIPE_ERROR_CREATE_PIPE_STREAM -4
+#define MC_PIPE_ERROR_READ -5
 
 /*** enums ***************************************************************************************/
 
 /* Pathname canonicalization */
@@ -50,8 +57,39 @@
     COMPRESSION_LZMA,
     COMPRESSION_XZ
 };
 
+/* stdout or stderr stream of child process */
+typedef struct
+{
+    /* file descriptor */
+    int fd;
+    /* data read from fd */
+    char buf[MC_PIPE_BUFSIZE];
+    /* positive: length of data in buf as before read as after;
+     * zero or negative before read: do not read drom fd;
+     * MC_PIPE_STREAM_EOF after read: EOF of fd;
+     * MC_PIPE_STREAM_UNREAD after read: there was not read from fd;
+     * MC_PIPE_ERROR_READ after read: reading error from fd.
+     */
+    ssize_t len;
+    /* whether buf is null-terminated or not */
+    gboolean null_term;
+    /* error code in case of len == MC_PIPE_ERROR_READ */
+    int error;
+} mc_pipe_stream_t;
+
+/* Pipe descriptor for child process */
+typedef struct
+{
+    /* PID of child process */
+    GPid child_pid;
+    /* stdout of child process */
+    mc_pipe_stream_t out;
+    /* stderr of child process */
+    mc_pipe_stream_t err;
+} mc_pipe_t;
+
 /*** structures declarations (and typedefs of structures)*****************************************/
 
 /* keys are set only during sorting */
 typedef struct
@@ -156,8 +194,12 @@
 int my_systeml (int flags, const char *shell, ...);
 int my_systemv (const char *command, char *const argv[]);
 int my_systemv_flags (int flags, const char *command, char *const argv[]);
 
+mc_pipe_t *mc_popen (const char *command, GError ** error);
+void mc_pread (mc_pipe_t * p, GError ** error);
+void mc_pclose (mc_pipe_t * p, GError ** error);
+
 void my_exit (int status);
 void save_stop_handler (void);
 
 /* Tilde expansion */
--- a/lib/utilunix.c
+++ b/lib/utilunix.c
@@ -49,8 +49,11 @@
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
 #include <sys/stat.h>
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
 #include <sys/wait.h>
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
@@ -232,8 +235,52 @@
     return args_array;
 }
 
 /* --------------------------------------------------------------------------------------------- */
+
+static void
+mc_pread_stream (mc_pipe_stream_t * ps, const fd_set * fds)
+{
+    size_t buf_len;
+    ssize_t read_len;
+
+    if (!FD_ISSET (ps->fd, fds))
+    {
+        ps->len = MC_PIPE_STREAM_UNREAD;
+        return;
+    }
+
+    buf_len = (size_t) ps->len;
+
+    if (buf_len >= MC_PIPE_BUFSIZE)
+        buf_len = ps->null_term ? MC_PIPE_BUFSIZE - 1 : MC_PIPE_BUFSIZE;
+
+    do
+    {
+        read_len = read (ps->fd, ps->buf, buf_len);
+    }
+    while (read_len < 0 && errno == EINTR);
+
+    if (read_len < 0)
+    {
+        /* reading error */
+        ps->len = MC_PIPE_ERROR_READ;
+        ps->error = errno;
+    }
+    else if (read_len == 0)
+        /* EOF */
+        ps->len = MC_PIPE_STREAM_EOF;
+    else
+    {
+        /* success */
+        ps->len = read_len;
+
+        if (ps->null_term)
+            ps->buf[(size_t) ps->len] = '\0';
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
 /*** public functions ****************************************************************************/
 /* --------------------------------------------------------------------------------------------- */
 
 char *
@@ -450,8 +497,173 @@
     return status;
 }
 
 /* --------------------------------------------------------------------------------------------- */
+/**
+ * Create pipe and run child process.
+ *
+ * @parameter command command line of child process
+ * @paremeter error contains pointer to object to handle error code and message
+ *
+ * @return newly created object of mc_pipe_t class in success, NULL otherwise
+ */
+
+mc_pipe_t *
+mc_popen (const char *command, GError ** error)
+{
+    mc_pipe_t *p;
+    char **argv;
+
+    p = g_try_new (mc_pipe_t, 1);
+    if (p == NULL)
+    {
+        mc_replace_error (error, MC_PIPE_ERROR_CREATE_PIPE, "%s",
+                          _("Cannot create pipe descriptor"));
+        goto ret_err;
+    }
+
+    if (!g_shell_parse_argv (command, NULL, &argv, error))
+    {
+        mc_replace_error (error, MC_PIPE_ERROR_PARSE_COMMAND, "%s",
+                          _("Cannot parse command for pipe"));
+        goto ret_err;
+    }
+
+    if (!g_spawn_async_with_pipes (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL,
+                                   &p->child_pid, NULL, &p->out.fd, &p->err.fd, error))
+    {
+        mc_replace_error (error, MC_PIPE_ERROR_CREATE_PIPE_STREAM, "%s",
+                          _("Cannot create pipe streams"));
+        goto ret_err;
+    }
+
+    g_strfreev (argv);
+
+    p->out.buf[0] = '\0';
+    p->out.len = MC_PIPE_BUFSIZE;
+    p->out.null_term = FALSE;
+
+    p->err.buf[0] = '\0';
+    p->err.len = MC_PIPE_BUFSIZE;
+    p->err.null_term = FALSE;
+
+    return p;
+
+  ret_err:
+    g_free (p);
+    return NULL;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+/**
+ * Read stdout and stderr of pipe asynchronously.
+ *
+ * @parameter p pipe descriptor
+ *
+ * The lengths of read data contain in p->out.len and p->err.len.
+ * Before read, p->xxx.len is an input:
+ *   p->xxx.len > 0:  do read stream p->xxx and store data in p->xxx.buf;
+ *   p->xxx.len <= 0: do not read stream p->xxx.
+ *
+ * After read, p->xxx.len is an output and contains the following:
+ *   p->xxx.len > 0: an actual length of read data stored in p->xxx.buf;
+ *   p->xxx.len == MC_PIPE_STREAM_EOF: EOF of stream p->xxx;
+ *   p->xxx.len == MC_PIPE_STREAM_UNREAD: stream p->xxx was not read;
+ *   p->xxx.len == MC_PIPE_ERROR_READ: reading error, and p->xxx.errno is set appropriately.
+ *
+ * @paremeter error contains pointer to object to handle error code and message
+ */
+
+void
+mc_pread (mc_pipe_t * p, GError ** error)
+{
+    gboolean read_out, read_err;
+    fd_set fds;
+    int maxfd = 0;
+    int res;
+
+    if (error != NULL)
+        *error = NULL;
+
+    read_out = p->out.fd >= 0 && p->out.len > 0;
+    read_err = p->err.fd >= 0 && p->err.len > 0;
+
+    if (!read_out && !read_err)
+    {
+        p->out.len = MC_PIPE_STREAM_UNREAD;
+        p->err.len = MC_PIPE_STREAM_UNREAD;
+        return;
+    }
+
+    FD_ZERO (&fds);
+    if (read_out)
+    {
+        FD_SET (p->out.fd, &fds);
+        maxfd = p->out.fd;
+    }
+
+    if (read_err)
+    {
+        FD_SET (p->err.fd, &fds);
+        maxfd = max (maxfd, p->err.fd);
+    }
+
+    /* no timeout */
+    res = select (maxfd + 1, &fds, NULL, NULL, NULL);
+    if (res < 0 && errno != EINTR)
+    {
+        mc_propagate_error (error, MC_PIPE_ERROR_READ,
+                            _
+                            ("Unexpected error in select() reading data from a child process:\n%s"),
+                            unix_error_string (errno));
+        return;
+    }
+
+    if (read_out)
+        mc_pread_stream (&p->out, &fds);
+    else
+        p->out.len = MC_PIPE_STREAM_UNREAD;
+
+    if (read_err)
+        mc_pread_stream (&p->err, &fds);
+    else
+        p->err.len = MC_PIPE_STREAM_UNREAD;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+/**
+ * Close pipe and destroy pipe descriptor.
+ *
+ * @paremeter p pipe descriptor
+ * @paremeter error contains pointer to object to handle error code and message
+ */
+
+void
+mc_pclose (mc_pipe_t * p, GError ** error)
+{
+    int res;
+
+    if (p->out.fd >= 0)
+        res = close (p->out.fd);
+    if (p->err.fd >= 0)
+        res = close (p->err.fd);
+
+    do
+    {
+        int status;
+
+        res = waitpid (p->child_pid, &status, 0);
+    }
+    while (res < 0 && errno == EINTR);
+
+    if (res < 0)
+        mc_replace_error (error, MC_PIPE_ERROR_READ, _("Unexpected error in waitpid():\n%s"),
+                          unix_error_string (errno));
+
+    g_free (p);
+}
+
+/* --------------------------------------------------------------------------------------------- */
 
 /**
  * Perform tilde expansion if possible.
  *
--- a/src/viewer/datasource.c
+++ b/src/viewer/datasource.c
@@ -68,28 +68,29 @@
 /*** file scope type declarations ****************************************************************/
 
 /*** file scope variables ************************************************************************/
 
-/*** file scope functions ************************************************************************/
-/* --------------------------------------------------------------------------------------------- */
-
 /* --------------------------------------------------------------------------------------------- */
-/*** public functions ****************************************************************************/
+/*** file scope functions ************************************************************************/
 /* --------------------------------------------------------------------------------------------- */
 
 static void
-mcview_set_datasource_stdio_pipe (mcview_t * view, FILE * fp)
+mcview_set_datasource_stdio_pipe (mcview_t * view, mc_pipe_t * p)
 {
-#ifdef HAVE_ASSERT_H
-    assert (fp != NULL);
-#endif
+    p->out.len = MC_PIPE_BUFSIZE;
+    p->out.null_term = FALSE;
+    p->err.len = MC_PIPE_BUFSIZE;
+    p->err.null_term = TRUE;
     view->datasource = DS_STDIO_PIPE;
-    view->ds_stdio_pipe = fp;
+    view->ds_stdio_pipe = p;
+    view->pipe_first_err_msg = TRUE;
 
     mcview_growbuf_init (view);
 }
 
 /* --------------------------------------------------------------------------------------------- */
+/*** public functions ****************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
 
 void
 mcview_set_datasource_none (mcview_t * view)
 {
@@ -349,21 +350,16 @@
         break;
     case DS_STDIO_PIPE:
         if (view->ds_stdio_pipe != NULL)
         {
-            (void) pclose (view->ds_stdio_pipe);
+            mcview_growbuf_done (view);
             mcview_display (view);
-            close_error_pipe (D_NORMAL, NULL);
-            view->ds_stdio_pipe = NULL;
         }
         mcview_growbuf_free (view);
         break;
     case DS_VFS_PIPE:
         if (view->ds_vfs_pipe != -1)
-        {
-            (void) mc_close (view->ds_vfs_pipe);
-            view->ds_vfs_pipe = -1;
-        }
+            mcview_growbuf_done (view);
         mcview_growbuf_free (view);
         break;
     case DS_FILE:
         (void) mc_close (view->ds_file_fd);
@@ -400,46 +396,31 @@
 
 gboolean
 mcview_load_command_output (mcview_t * view, const char *command)
 {
-    FILE *fp;
+    mc_pipe_t *pipe;
+    GError *error = NULL;
 
     mcview_close_datasource (view);
 
-    open_error_pipe ();
-    fp = popen (command, "r");
-    if (fp == NULL)
+    pipe = mc_popen (command, &error);
+    if (pipe == NULL)
     {
-        /* Avoid two messages.  Message from stderr has priority.  */
         mcview_display (view);
-        if (!close_error_pipe (mcview_is_in_panel (view) ? -1 : D_ERROR, NULL))
-            mcview_show_error (view, _("Cannot spawn child process"));
+        mcview_show_error (view, error->message);
+        g_error_free (error);
         return FALSE;
     }
 
-    /* First, check if filter produced any output */
-    mcview_set_datasource_stdio_pipe (view, fp);
+    /* Check if filter produced any output */
+    mcview_set_datasource_stdio_pipe (view, pipe);
     if (!mcview_get_byte (view, 0, NULL))
     {
         mcview_close_datasource (view);
-
-        /* Avoid two messages.  Message from stderr has priority.  */
         mcview_display (view);
-        if (!close_error_pipe (mcview_is_in_panel (view) ? -1 : D_ERROR, NULL))
-            mcview_show_error (view, _("Empty output from child filter"));
         return FALSE;
     }
-    else
-    {
-        /*
-         * At least something was read correctly. Close stderr and let
-         * program die if it will try to write something there.
-         *
-         * Ideally stderr should be read asynchronously to prevent programs
-         * from blocking (poll/select multiplexor).
-         */
-        close_error_pipe (D_NORMAL, NULL);
-    }
+
     return TRUE;
 }
 
 /* --------------------------------------------------------------------------------------------- */
--- a/src/viewer/growbuf.c
+++ b/src/viewer/growbuf.c
@@ -13,9 +13,9 @@
    Norbert Warmuth, 1997
    Pavel Machek, 1998
    Roland Illig <roland.illig@gmx.de>, 2004, 2005
    Slava Zanko <slavazanko@google.com>, 2009
-   Andrew Borodin <aborodin@vmail.ru>, 2009
+   Andrew Borodin <aborodin@vmail.ru>, 2009, 2014
    Ilia Maslakov <il.smind@gmail.com>, 2009
 
    This file is part of the Midnight Commander.
 
@@ -72,8 +72,27 @@
 
 /* --------------------------------------------------------------------------------------------- */
 
 void
+mcview_growbuf_done (mcview_t * view)
+{
+    view->growbuf_finished = TRUE;
+
+    if (view->datasource == DS_STDIO_PIPE)
+    {
+        mc_pclose (view->ds_stdio_pipe, NULL);
+        view->ds_stdio_pipe = NULL;
+    }
+    else                        /* view->datasource == DS_VFS_PIPE */
+    {
+        (void) mc_close (view->ds_vfs_pipe);
+        view->ds_vfs_pipe = -1;
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
 mcview_growbuf_free (mcview_t * view)
 {
 #ifdef HAVE_ASSERT_H
     assert (view->growbuf_in_use);
@@ -110,21 +129,20 @@
 
 void
 mcview_growbuf_read_until (mcview_t * view, off_t ofs)
 {
-    ssize_t nread;
-    gboolean short_read;
+    gboolean short_read = FALSE;
 
 #ifdef HAVE_ASSERT_H
     assert (view->growbuf_in_use);
 #endif
 
     if (view->growbuf_finished)
         return;
 
-    short_read = FALSE;
     while (mcview_growbuf_filesize (view) < ofs || short_read)
     {
+        ssize_t nread = 0;
         byte *p;
         size_t bytesfree;
 
         if (view->growbuf_lastindex == VIEW_PAGE_SIZE)
@@ -143,16 +161,58 @@
         bytesfree = VIEW_PAGE_SIZE - view->growbuf_lastindex;
 
         if (view->datasource == DS_STDIO_PIPE)
         {
-            nread = fread (p, 1, bytesfree, view->ds_stdio_pipe);
-            if (nread == 0)
+            mc_pipe_t *sp = view->ds_stdio_pipe;
+            GError *error = NULL;
+
+            if (bytesfree > MC_PIPE_BUFSIZE)
+                bytesfree = MC_PIPE_BUFSIZE;
+
+            sp->out.len = bytesfree;
+            sp->err.len = MC_PIPE_BUFSIZE;
+
+            mc_pread (sp, &error);
+
+            if (error != NULL)
             {
-                view->growbuf_finished = TRUE;
-                (void) pclose (view->ds_stdio_pipe);
+                mcview_show_error (view, error->message);
+                g_error_free (error);
+                mcview_growbuf_done (view);
+                return;
+            }
+
+            if (view->pipe_first_err_msg && sp->err.len > 0)
+            {
+                /* ignore possible following errors */
+                /* reset this flag before call of mcview_show_error() to break
+                 * endless recursion: mcview_growbuf_read_until() -> mcview_show_error() ->
+                 * MSG_DRAW -> mcview_display() -> mcview_get_byte() -> mcview_growbuf_read_until()
+                 */
+                view->pipe_first_err_msg = FALSE;
+
+                mcview_show_error (view, sp->err.buf);
+            }
+
+            if (sp->out.len > 0)
+            {
+                memmove (p, sp->out.buf, sp->out.len);
+                nread = sp->out.len;
+            }
+            else if (sp->out.len == MC_PIPE_STREAM_EOF || sp->out.len == MC_PIPE_ERROR_READ)
+            {
+                if (sp->out.len == MC_PIPE_ERROR_READ)
+                {
+                    char *err_msg;
+
+                    err_msg = g_strdup_printf (_("Failed to read data from child stdout:\n%s"),
+                                               unix_error_string (sp->out.error));
+                    mcview_show_error (view, err_msg);
+                    g_free (err_msg);
+                }
+
+                mcview_growbuf_done (view);
                 mcview_display (view);
-                close_error_pipe (D_NORMAL, NULL);
-                view->ds_stdio_pipe = NULL;
                 return;
             }
         }
         else
@@ -164,13 +224,12 @@
             {
                 nread = mc_read (view->ds_vfs_pipe, p, bytesfree);
             }
             while (nread == -1 && errno == EINTR);
-            if (nread == -1 || nread == 0)
+
+            if (nread <= 0)
             {
-                view->growbuf_finished = TRUE;
-                (void) mc_close (view->ds_vfs_pipe);
-                view->ds_vfs_pipe = -1;
+                mcview_growbuf_done (view);
                 return;
             }
         }
         short_read = ((size_t) nread < bytesfree);
--- a/src/viewer/internal.h
+++ b/src/viewer/internal.h
@@ -99,9 +99,10 @@
 
     enum view_ds datasource;    /* Where the displayed data comes from */
 
     /* stdio pipe data source */
-    FILE *ds_stdio_pipe;        /* Output of a shell command */
+    mc_pipe_t *ds_stdio_pipe;   /* Output of a shell command */
+    gboolean pipe_first_err_msg;        /* Show only 1st message from stderr */
 
     /* vfs pipe data source */
     int ds_vfs_pipe;            /* Non-seekable vfs file descriptor */
 
@@ -262,8 +263,9 @@
 void mcview_display_ruler (mcview_t * view);
 
 /* growbuf.c: */
 void mcview_growbuf_init (mcview_t * view);
+void mcview_growbuf_done (mcview_t * view);
 void mcview_growbuf_free (mcview_t * view);
 off_t mcview_growbuf_filesize (mcview_t * view);
 void mcview_growbuf_read_until (mcview_t * view, off_t p);
 gboolean mcview_get_byte_growing_buffer (mcview_t * view, off_t p, int *);
--- a/src/viewer/lib.c
+++ b/src/viewer/lib.c
@@ -303,17 +303,12 @@
 
 void
 mcview_show_error (mcview_t * view, const char *msg)
 {
-    mcview_close_datasource (view);
     if (mcview_is_in_panel (view))
-    {
         mcview_set_datasource_string (view, msg);
-    }
     else
-    {
         message (D_ERROR, MSG_ERROR, "%s", msg);
-    }
 }
 
 /* --------------------------------------------------------------------------------------------- */
 /** returns index of the first char in the line
--- a/src/viewer/mcviewer.c
+++ b/src/viewer/mcviewer.c
@@ -324,8 +324,9 @@
         if (fd == -1)
         {
             g_snprintf (tmp, sizeof (tmp), _("Cannot open \"%s\"\n%s"),
                         file, unix_error_string (errno));
+            mcview_close_datasource (view);
             mcview_show_error (view, tmp);
             vfs_path_free (view->filename_vpath);
             view->filename_vpath = NULL;
             vfs_path_free (view->workdir_vpath);
@@ -338,8 +339,9 @@
         {
             mc_close (fd);
             g_snprintf (tmp, sizeof (tmp), _("Cannot stat \"%s\"\n%s"),
                         file, unix_error_string (errno));
+            mcview_close_datasource (view);
             mcview_show_error (view, tmp);
             vfs_path_free (view->filename_vpath);
             view->filename_vpath = NULL;
             vfs_path_free (view->workdir_vpath);
@@ -349,8 +351,9 @@
 
         if (!S_ISREG (st.st_mode))
         {
             mc_close (fd);
+            mcview_close_datasource (view);
             mcview_show_error (view, _("Cannot view: not a regular file"));
             vfs_path_free (view->filename_vpath);
             view->filename_vpath = NULL;
             vfs_path_free (view->workdir_vpath);
@@ -381,8 +384,9 @@
                 if (fd1 == -1)
                 {
                     g_snprintf (tmp, sizeof (tmp), _("Cannot open \"%s\" in parse mode\n%s"),
                                 file, unix_error_string (errno));
+                    mcview_close_datasource (view);
                     mcview_show_error (view, tmp);
                 }
                 else
                 {
