diff -ur mc-4.6.2-pre1.orig/slang/slcommon.c mc-4.6.2-pre1/slang/slcommon.c
--- mc-4.6.2-pre1.orig/slang/slcommon.c	2006-02-15 18:10:55.000000000 +0300
+++ mc-4.6.2-pre1/slang/slcommon.c	2008-07-06 18:31:21.000000000 +0400
@@ -31,7 +31,7 @@
 # include <locale.h>
 #endif
 
-#ifdef HAVE_LANGINFO_H
+#ifdef HAVE_LANGINFO_CODESET
 # include <langinfo.h>
 #endif
 
@@ -87,7 +87,7 @@
 
    (void) setlocale (LC_ALL, "");
 
-#ifdef HAVE_NL_LANGINFO_CODESET
+#ifdef HAVE_LANGINFO_CODESET
    locale = nl_langinfo (CODESET);
    if ((locale != NULL) && (*locale))
      {
diff -ur mc-4.6.2-pre1.orig/src/main.c mc-4.6.2-pre1/src/main.c
--- mc-4.6.2-pre1.orig/src/main.c	2008-07-06 18:31:02.000000000 +0400
+++ mc-4.6.2-pre1/src/main.c	2008-07-06 18:31:21.000000000 +0400
@@ -24,6 +24,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <locale.h>
+#include <langinfo.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -276,6 +277,9 @@
 /* The user's shell */
 const char *shell = NULL;
 
+/* Is the LANG UTF-8 ? */
+gboolean is_utf8 = FALSE;
+
 /* The xterm title */
 char *xterm_title_str = NULL;
 
@@ -2163,6 +2167,12 @@
     bindtextdomain ("mc", LOCALEDIR);
     textdomain ("mc");
 
+#ifdef HAVE_LANGINFO_CODESET
+    char *codeset = nl_langinfo (CODESET);
+    if (codeset && !strcasecmp (codeset, "UTF-8"))
+	is_utf8 = TRUE;
+#endif
+
     /* Set up temporary directory */
     mc_tmpdir ();
 
diff -ur mc-4.6.2-pre1.orig/src/main.h mc-4.6.2-pre1/src/main.h
--- mc-4.6.2-pre1.orig/src/main.h	2008-07-06 18:31:02.000000000 +0400
+++ mc-4.6.2-pre1/src/main.h	2008-07-06 18:31:09.000000000 +0400
@@ -69,6 +69,7 @@
 extern int only_leading_plus_minus;
 extern int output_starts_shell;
 extern int midnight_shutdown;
+extern gboolean is_utf8;
 extern char *xterm_title_str;
 extern char cmd_buf [512];
 extern const char *shell;
diff -ur mc-4.6.2-pre1.orig/src/screen.c mc-4.6.2-pre1/src/screen.c
--- mc-4.6.2-pre1.orig/src/screen.c	2008-07-06 18:31:02.000000000 +0400
+++ mc-4.6.2-pre1/src/screen.c	2008-07-06 18:31:09.000000000 +0400
@@ -888,6 +888,9 @@
     }
 #endif				/* HAVE_SLANG */
 
+    vscrollbar (panel->widget, panel->widget.lines, panel->widget.cols-1, 2, 2,
+		panel->selected, panel->count, TRUE);
+
     if (panel->active)
 	attrset (REVERSE_COLOR);
 
@@ -1488,7 +1491,7 @@
     panel->dirty = 1;
 
     /* Status needn't to be split */
-    usable_columns = ((panel->widget.cols-2)/((isstatus)
+    usable_columns = ((panel->widget.cols-3)/((isstatus)
 					      ? 1
 					      : (panel->split+1))) - (!isstatus && panel->split);
 
diff -ur mc-4.6.2-pre1.orig/src/widget.c mc-4.6.2-pre1/src/widget.c
--- mc-4.6.2-pre1.orig/src/widget.c	2008-07-06 18:31:02.000000000 +0400
+++ mc-4.6.2-pre1/src/widget.c	2008-07-06 18:31:09.000000000 +0400
@@ -1945,52 +1945,86 @@
     return in;
 }
 
-
-/* Listbox widget */
-
-/* Should draw the scrollbar, but currently draws only
- * indications that there is more information
- */
-static int listbox_cdiff (WLEntry *s, WLEntry *e);
+/* Vertical scrollbar widget */
 
-static void
-listbox_drawscroll (WListbox *l)
+void
+vscrollbar (Widget widget, int height, int width, int tpad, int bpad,
+            int selected, int count, gboolean color)
 {
     int line;
-    int i, top;
-    int max_line = l->height-1;
-    
+    int i;
+
     /* Are we at the top? */
-    widget_move (&l->widget, 0, l->width);
-    if (l->list == l->top)
-	one_vline ();
+    widget_move (&widget, tpad, width);
+#ifndef UTF8
+    if (!selected)
+        one_vline ();
     else
-	addch ('^');
+        addch ('^');
+#else
+    if (color) attrset (MARKED_COLOR);
+    if (is_utf8)
+	SLsmg_write_string("↑");
+    else
+        addch ('^');
+    if (color) attrset (NORMAL_COLOR);
+#endif
 
     /* Are we at the bottom? */
-    widget_move (&l->widget, max_line, l->width);
-    top = listbox_cdiff (l->list, l->top);
-    if ((top + l->height == l->count) || l->height >= l->count)
-	one_vline ();
+    widget_move (&widget, height-1-bpad, width);
+#ifndef UTF8
+    if (selected == count-1)
+        one_vline ();
+    else
+        addch ('v');
+#else
+    if (color) attrset (MARKED_COLOR);
+    if (is_utf8)
+	SLsmg_write_string("↓");
     else
-	addch ('v');
+	addch('v');
+    if (color) attrset (NORMAL_COLOR);
+#endif
 
     /* Now draw the nice relative pointer */
-    if (l->count)
-	line = 1+ ((l->pos * (l->height-2)) / l->count);
+    if (count > 1)
+        line = tpad + 1 + ((selected * (height-3-tpad-bpad)) / (count-1));
     else
-	line = 0;
-    
-    for (i = 1; i < max_line; i++){
-	widget_move (&l->widget, i, l->width);
-	if (i != line)
-	    one_vline ();
-	else
-	    addch ('*');
+        line = 0;
+
+    for (i = tpad + 1; i < height-1-bpad; i++){
+        widget_move (&widget, i, width);
+        if (i != line)
+#ifndef UTF8
+            one_vline ();
+        else
+            addch ('*');
+#else
+            if (is_utf8)
+		SLsmg_write_string("▒");
+	    else
+		one_vline();
+        else {
+            if (color) attrset (MARKED_COLOR);
+            if (is_utf8)
+		SLsmg_write_string("▮");
+	    else
+		addch('*');
+            if (color) attrset (NORMAL_COLOR);
+        }
+#endif
     }
 }
-    
-static void
+
+
+/* Listbox widget */
+
+/* Should draw the scrollbar, but currently draws only
+ * indications that there is more information
+ */
+static int listbox_cdiff (WLEntry *s, WLEntry *e);
+
+void
 listbox_draw (WListbox *l, int focused)
 {
     WLEntry *e;
@@ -2031,7 +2065,7 @@
     if (!l->scrollbar)
 	return;
     attrset (normalc);
-    listbox_drawscroll (l);
+    vscrollbar (l->widget, l->height, l->width, 0, 0, l->pos, l->count, FALSE);
 }
 
 /* Returns the number of items between s and e,
diff -ur mc-4.6.2-pre1.orig/src/widget.h mc-4.6.2-pre1/src/widget.h
--- mc-4.6.2-pre1.orig/src/widget.h	2008-07-06 18:31:02.000000000 +0400
+++ mc-4.6.2-pre1/src/widget.h	2008-07-06 18:31:09.000000000 +0400
@@ -169,6 +169,10 @@
 /* Listbox manager */
 WLEntry *listbox_get_data (WListbox *l, int pos);
 
+/* Vertical scrollbar */
+void vscrollbar (Widget widget, int height, int width, int tpad, int bpad,
+        	int selected, int count, gboolean color);
+
 /* search text int listbox entries */
 WLEntry *listbox_search_text (WListbox *l, const char *text);
 void listbox_select_entry (WListbox *l, WLEntry *dest);
