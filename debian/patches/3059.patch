Last-Update: 2013-09-17
Forwarded: not-needed
Author: Dmitry Smirnov <onlyjob@member.fsf.org>
Origin: upstream, http://www.midnight-commander.org/changeset/1ae697368c933a5967416acdc7834102d6ac484d
Origin: upstream, http://www.midnight-commander.org/changeset/7871894760903e67af774ba572afeacda38b09f1
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=722891
Bug-MC: https://www.midnight-commander.org/ticket/3059
Bug-MC: https://www.midnight-commander.org/ticket/2075
Description: fix "compute totals" progress bar and segfault on copy/move operations.

--- a/src/filemanager/file.c
+++ b/src/filemanager/file.c
@@ -1271,19 +1271,19 @@
 /* --------------------------------------------------------------------------------------------- */
 
 /** Initialize variables for progress bars */
 static FileProgressStatus
-panel_operate_init_totals (FileOperation operation, const WPanel * panel, const char *source,
-                           FileOpContext * ctx, filegui_dialog_type_t dialog_type)
+panel_operate_init_totals (const WPanel * panel, const char *source, FileOpContext * ctx,
+                           filegui_dialog_type_t dialog_type)
 {
     FileProgressStatus status;
 
 #ifdef ENABLE_BACKGROUND
     if (mc_global.we_are_background)
         return FILE_CONT;
 #endif
 
-    if (operation != OP_MOVE && verbose && file_op_compute_totals)
+    if (verbose && file_op_compute_totals)
     {
         ComputeDirSizeUI *ui;
 
         ui = compute_dir_size_create_ui (TRUE);
@@ -2377,15 +2377,8 @@
 
     mc_refresh ();
     if (ctx->erase_at_end)
     {
-        /* remove files after move */
-        if (erase_list != NULL)
-        {
-            file_op_context_destroy_ui (ctx);
-            file_op_context_create_ui (ctx, FALSE, FILEGUI_DIALOG_DELETE_ITEM);
-        }
-
         while (erase_list != NULL && return_status != FILE_ABORT)
         {
             struct link *lp = (struct link *) erase_list->data;
 
@@ -2791,16 +2784,14 @@
 #endif /* ENABLE_BACKGROUND */
     {
         if (operation == OP_DELETE)
             dialog_type = FILEGUI_DIALOG_DELETE_ITEM;
+        else if (single_entry && S_ISDIR (selection (panel)->st.st_mode))
+            dialog_type = FILEGUI_DIALOG_MULTI_ITEM;
+        else if (single_entry || force_single)
+            dialog_type = FILEGUI_DIALOG_ONE_ITEM;
         else
-        {
-            dialog_type = ((operation != OP_COPY) || single_entry || force_single)
-                ? FILEGUI_DIALOG_ONE_ITEM : FILEGUI_DIALOG_MULTI_ITEM;
-
-            if (single_entry && (operation == OP_COPY) && S_ISDIR (selection (panel)->st.st_mode))
-                dialog_type = FILEGUI_DIALOG_MULTI_ITEM;
-        }
+            dialog_type = FILEGUI_DIALOG_MULTI_ITEM;
     }
 
     /* Initialize things */
     /* We do not want to trash cache every time file is
@@ -2843,10 +2834,10 @@
             source_with_vpath = vfs_path_from_str (source);
         else
             source_with_vpath = vfs_path_append_new (panel->cwd_vpath, source, (char *) NULL);
 #endif /* WITH_FULL_PATHS */
-        if (panel_operate_init_totals
-            (operation, panel, vfs_path_as_str (source_with_vpath), ctx, dialog_type) == FILE_CONT)
+        if (panel_operate_init_totals (panel, vfs_path_as_str (source_with_vpath), ctx, dialog_type)
+            == FILE_CONT)
         {
             if (operation == OP_DELETE)
             {
                 if (S_ISDIR (src_stat.st_mode))
@@ -2935,9 +2926,9 @@
                 || file_error (_("Destination \"%s\" must be a directory\n%s"), dest) != FILE_RETRY)
                 goto clean_up;
         }
 
-        if (panel_operate_init_totals (operation, panel, NULL, ctx, dialog_type) == FILE_CONT)
+        if (panel_operate_init_totals (panel, NULL, ctx, dialog_type) == FILE_CONT)
         {
             /* Loop for every file, perform the actual copy operation */
             for (i = 0; i < panel->count; i++)
             {
